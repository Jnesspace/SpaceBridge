// Package generator creates Tofu code from a Spacelift manifest.
package generator

import (
	"encoding/base64"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/jnesspace/spacebridge/internal/discovery"
	"github.com/jnesspace/spacebridge/internal/models"
	"github.com/jnesspace/spacebridge/pkg/config"
)

// Generator creates Tofu code from a manifest.
type Generator struct {
	manifest        *discovery.Manifest
	outputDir       string
	safeMode        bool                     // Force autodeploy=false for safe state migration
	autodeployList  []string                 // Stacks that originally had autodeploy=true
	destConfig      *config.AccountConfig    // Destination account config for provider
	migrationConfig *config.MigrationConfig  // Migration config for VCS overrides
}

// New creates a new generator.
func New(manifest *discovery.Manifest, outputDir string) *Generator {
	return &Generator{
		manifest:  manifest,
		outputDir: outputDir,
	}
}

// WithSafeMode sets the generator to force autodeploy=false for safe migration.
func (g *Generator) WithSafeMode(safe bool) *Generator {
	g.safeMode = safe
	return g
}

// WithDestinationConfig sets the destination account config for provider.tf.
func (g *Generator) WithDestinationConfig(cfg *config.AccountConfig) *Generator {
	g.destConfig = cfg
	return g
}

// WithMigrationConfig sets the migration config for VCS overrides.
func (g *Generator) WithMigrationConfig(cfg *config.MigrationConfig) *Generator {
	g.migrationConfig = cfg
	return g
}

// Generate creates all Tofu files.
func (g *Generator) Generate() error {
	// Create output directory
	if err := os.MkdirAll(g.outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Generate main.tf with all resources
	mainTF, err := g.generateMain()
	if err != nil {
		return fmt.Errorf("failed to generate main.tf: %w", err)
	}
	if err := g.writeFile("main.tf", mainTF); err != nil {
		return err
	}

	// Generate variables.tf for secrets
	variablesTF := g.generateVariables()
	if err := g.writeFile("variables.tf", variablesTF); err != nil {
		return err
	}

	// Generate secrets.auto.tfvars.template
	secretsTemplate := g.generateSecretsTemplate()
	if err := g.writeFile("secrets.auto.tfvars.template", secretsTemplate); err != nil {
		return err
	}

	// Generate provider.tf
	providerTF := g.generateProvider()
	if err := g.writeFile("provider.tf", providerTF); err != nil {
		return err
	}

	// Generate autodeploy re-enable list if in safe mode
	if g.safeMode && len(g.autodeployList) > 0 {
		autodeployTF := g.generateAutodeployReEnable()
		if err := g.writeFile("autodeploy_re_enable.tf.disabled", autodeployTF); err != nil {
			return err
		}
	}

	return nil
}

// writeFile writes content to a file in the output directory.
func (g *Generator) writeFile(filename, content string) error {
	path := filepath.Join(g.outputDir, filename)
	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write %s: %w", filename, err)
	}
	fmt.Printf("  Created: %s\n", path)
	return nil
}

// generateProvider creates the provider configuration.
func (g *Generator) generateProvider() string {
	var sb strings.Builder

	sb.WriteString(`# Provider configuration for Spacelift
# Documentation: https://registry.opentofu.org/providers/spacelift-io/spacelift/latest/docs

terraform {
  required_providers {
    spacelift = {
      source  = "spacelift-io/spacelift"
      version = "~> 1.0"
    }
  }
}

`)

	if g.destConfig != nil && g.destConfig.URL != "" {
		// Use destination config from environment
		sb.WriteString("# Configured for destination account\n")
		sb.WriteString("provider \"spacelift\" {\n")
		sb.WriteString(fmt.Sprintf("  api_key_endpoint = %q\n", g.destConfig.URL))
		sb.WriteString(fmt.Sprintf("  api_key_id       = %q\n", g.destConfig.KeyID))
		sb.WriteString(fmt.Sprintf("  api_key_secret   = %q\n", g.destConfig.SecretKey))
		sb.WriteString("}\n")
	} else {
		// Fallback to placeholder
		sb.WriteString(`# Configure the Spacelift provider
# Set SPACELIFT_API_KEY_ENDPOINT, SPACELIFT_API_KEY_ID, and SPACELIFT_API_KEY_SECRET
# environment variables, or configure below:
provider "spacelift" {
  # api_key_endpoint = "https://your-account.app.spacelift.io"
  # api_key_id       = "your-api-key-id"
  # api_key_secret   = "your-api-key-secret"
}
`)
	}

	return sb.String()
}

// generateMain creates the main.tf with all resources.
func (g *Generator) generateMain() (string, error) {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf(`# Generated by SpaceBridge
# Source: %s
#
# This file contains all Spacelift resources exported from the source account.
# Review and modify as needed before applying.

`, g.manifest.SourceURL))

	// Generate spaces (in dependency order - parents before children)
	sb.WriteString("# =============================================================================\n")
	sb.WriteString("# SPACES\n")
	sb.WriteString("# =============================================================================\n\n")
	sortedSpaces := g.sortSpacesByDependency()
	for _, space := range sortedSpaces {
		if space.ID == "root" {
			continue // Skip root space - it always exists
		}
		sb.WriteString(g.generateSpace(space))
		sb.WriteString("\n")
	}

	// Generate contexts
	sb.WriteString("# =============================================================================\n")
	sb.WriteString("# CONTEXTS\n")
	sb.WriteString("# =============================================================================\n\n")
	for _, ctx := range g.manifest.Contexts {
		sb.WriteString(g.generateContext(ctx))
		sb.WriteString("\n")
	}

	// Generate environment variables and mounted files for contexts
	sb.WriteString("# =============================================================================\n")
	sb.WriteString("# CONTEXT CONFIGURATION (Environment Variables & Mounted Files)\n")
	sb.WriteString("# =============================================================================\n\n")
	for _, ctx := range g.manifest.Contexts {
		for _, cfg := range ctx.Config {
			sb.WriteString(g.generateConfigElement(ctx.ID, cfg))
			sb.WriteString("\n")
		}
	}

	// Generate policies
	sb.WriteString("# =============================================================================\n")
	sb.WriteString("# POLICIES\n")
	sb.WriteString("# =============================================================================\n\n")
	for _, policy := range g.manifest.Policies {
		sb.WriteString(g.generatePolicy(policy))
		sb.WriteString("\n")
	}

	// Generate stacks
	sb.WriteString("# =============================================================================\n")
	sb.WriteString("# STACKS\n")
	sb.WriteString("# =============================================================================\n\n")
	for _, stack := range g.manifest.Stacks {
		// Track stacks that originally had autodeploy enabled
		if g.safeMode && stack.Autodeploy {
			g.autodeployList = append(g.autodeployList, stack.Name)
		}
		sb.WriteString(g.generateStack(stack))
		sb.WriteString("\n")
	}

	// Generate context attachments
	sb.WriteString("# =============================================================================\n")
	sb.WriteString("# CONTEXT ATTACHMENTS\n")
	sb.WriteString("# =============================================================================\n\n")
	for _, stack := range g.manifest.Stacks {
		for _, attachment := range stack.AttachedContexts {
			sb.WriteString(g.generateContextAttachment(stack.ID, attachment))
			sb.WriteString("\n")
		}
	}

	// Generate policy attachments
	sb.WriteString("# =============================================================================\n")
	sb.WriteString("# POLICY ATTACHMENTS\n")
	sb.WriteString("# =============================================================================\n\n")
	for _, stack := range g.manifest.Stacks {
		for _, attachment := range stack.AttachedPolicies {
			sb.WriteString(g.generatePolicyAttachment(stack.ID, attachment))
			sb.WriteString("\n")
		}
	}

	// Generate stack dependencies
	sb.WriteString("# =============================================================================\n")
	sb.WriteString("# STACK DEPENDENCIES\n")
	sb.WriteString("# =============================================================================\n\n")
	for _, stack := range g.manifest.Stacks {
		for _, dep := range stack.DependsOn {
			sb.WriteString(g.generateStackDependency(stack.ID, dep))
			sb.WriteString("\n")
		}
	}

	// Generate admin role attachments (replaces deprecated administrative = true)
	hasAdminStacks := false
	for _, stack := range g.manifest.Stacks {
		if stack.Administrative {
			hasAdminStacks = true
			break
		}
	}
	if hasAdminStacks {
		sb.WriteString("# =============================================================================\n")
		sb.WriteString("# ADMIN ROLE & ATTACHMENTS\n")
		sb.WriteString("# Replaces deprecated 'administrative = true' flag on stacks\n")
		sb.WriteString("# =============================================================================\n\n")
		sb.WriteString(g.generateAdminRole())
		sb.WriteString("\n")
		for _, stack := range g.manifest.Stacks {
			if stack.Administrative {
				sb.WriteString(g.generateAdminRoleAttachment(stack))
				sb.WriteString("\n")
			}
		}
	}

	// Generate AWS integrations
	sb.WriteString("# =============================================================================\n")
	sb.WriteString("# AWS INTEGRATIONS\n")
	sb.WriteString("# =============================================================================\n\n")
	if len(g.manifest.AWSIntegrations) > 0 {
		sb.WriteString("# NOTE: AWS integrations require IAM trust policy updates in your AWS account.\n")
		sb.WriteString("# The destination Spacelift account's OIDC provider must be trusted by the IAM role.\n\n")
	}
	for _, integration := range g.manifest.AWSIntegrations {
		sb.WriteString(g.generateAWSIntegration(integration))
		sb.WriteString("\n")
	}

	// Generate Azure integrations
	sb.WriteString("# =============================================================================\n")
	sb.WriteString("# AZURE INTEGRATIONS\n")
	sb.WriteString("# =============================================================================\n\n")
	if len(g.manifest.AzureIntegrations) > 0 {
		sb.WriteString("# NOTE: Azure integrations require app registration updates in Azure AD.\n")
		sb.WriteString("# The destination Spacelift account must be configured as a trusted identity provider.\n\n")
	}
	for _, integration := range g.manifest.AzureIntegrations {
		sb.WriteString(g.generateAzureIntegration(integration))
		sb.WriteString("\n")
	}

	// Generate AWS integration attachments
	sb.WriteString("# =============================================================================\n")
	sb.WriteString("# AWS INTEGRATION ATTACHMENTS\n")
	sb.WriteString("# =============================================================================\n\n")
	for _, stack := range g.manifest.Stacks {
		for _, attachment := range stack.AttachedAWSIntegrations {
			sb.WriteString(g.generateAWSIntegrationAttachment(stack.ID, attachment))
			sb.WriteString("\n")
		}
	}

	// Generate Azure integration attachments
	sb.WriteString("# =============================================================================\n")
	sb.WriteString("# AZURE INTEGRATION ATTACHMENTS\n")
	sb.WriteString("# =============================================================================\n\n")
	for _, stack := range g.manifest.Stacks {
		for _, attachment := range stack.AttachedAzureIntegrations {
			sb.WriteString(g.generateAzureIntegrationAttachment(stack.ID, attachment))
			sb.WriteString("\n")
		}
	}

	return sb.String(), nil
}

// generateSpace creates Tofu for a space.
func (g *Generator) generateSpace(space models.Space) string {
	resourceName := sanitizeResourceName(space.ID)

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("resource \"spacelift_space\" %q {\n", resourceName))
	sb.WriteString(fmt.Sprintf("  name = %q\n", space.Name))

	// Parent space reference
	if space.ParentSpace != nil && *space.ParentSpace != "" && *space.ParentSpace != "root" {
		parentResource := sanitizeResourceName(*space.ParentSpace)
		sb.WriteString(fmt.Sprintf("  parent_space_id = spacelift_space.%s.id\n", parentResource))
	} else if space.ParentSpace != nil && *space.ParentSpace == "root" {
		sb.WriteString("  parent_space_id = \"root\"\n")
	}

	if space.Description != "" {
		sb.WriteString(fmt.Sprintf("  description = %q\n", space.Description))
	}

	sb.WriteString(fmt.Sprintf("  inherit_entities = %t\n", space.InheritEntities))

	if len(space.Labels) > 0 {
		sb.WriteString(fmt.Sprintf("  labels = %s\n", formatStringList(space.Labels)))
	}

	sb.WriteString("}\n")
	return sb.String()
}

// generateContext creates Tofu for a context.
func (g *Generator) generateContext(ctx models.Context) string {
	resourceName := sanitizeResourceName(ctx.ID)

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("resource \"spacelift_context\" %q {\n", resourceName))
	sb.WriteString(fmt.Sprintf("  name = %q\n", ctx.Name))

	// Space reference
	if ctx.Space != "root" {
		spaceResource := sanitizeResourceName(ctx.Space)
		sb.WriteString(fmt.Sprintf("  space_id = spacelift_space.%s.id\n", spaceResource))
	} else {
		sb.WriteString("  space_id = \"root\"\n")
	}

	if ctx.Description != nil && *ctx.Description != "" {
		sb.WriteString(fmt.Sprintf("  description = %q\n", *ctx.Description))
	}

	if len(ctx.Labels) > 0 {
		sb.WriteString(fmt.Sprintf("  labels = %s\n", formatStringList(ctx.Labels)))
	}

	// Hooks
	g.writeHooks(&sb, ctx.Hooks)

	sb.WriteString("}\n")
	return sb.String()
}

// generateConfigElement creates Tofu for an env var or mounted file.
func (g *Generator) generateConfigElement(contextID string, cfg models.ConfigElement) string {
	contextResource := sanitizeResourceName(contextID)
	varName := sanitizeResourceName(contextID + "_" + cfg.ID)

	var sb strings.Builder

	if cfg.Type == "ENVIRONMENT_VARIABLE" {
		sb.WriteString(fmt.Sprintf("resource \"spacelift_environment_variable\" %q {\n", varName))
		sb.WriteString(fmt.Sprintf("  context_id = spacelift_context.%s.id\n", contextResource))
		sb.WriteString(fmt.Sprintf("  name       = %q\n", cfg.ID))

		if cfg.WriteOnly {
			// Secret - reference variable
			secretVarName := sanitizeVariableName(contextID + "_" + cfg.ID)
			sb.WriteString(fmt.Sprintf("  value      = var.secret_%s\n", secretVarName))
		} else {
			// Non-secret - use actual value
			sb.WriteString(fmt.Sprintf("  value      = %q\n", cfg.Value))
		}

		sb.WriteString(fmt.Sprintf("  write_only = %t\n", cfg.WriteOnly))
		sb.WriteString("}\n")
	} else if cfg.Type == "FILE_MOUNT" {
		sb.WriteString(fmt.Sprintf("resource \"spacelift_mounted_file\" %q {\n", varName))
		sb.WriteString(fmt.Sprintf("  context_id    = spacelift_context.%s.id\n", contextResource))
		sb.WriteString(fmt.Sprintf("  relative_path = %q\n", cfg.ID))

		if cfg.WriteOnly {
			// Secret file - reference variable
			secretVarName := sanitizeVariableName(contextID + "_" + cfg.ID)
			sb.WriteString(fmt.Sprintf("  content      = base64encode(var.secret_%s)\n", secretVarName))
		} else {
			// Non-secret - use actual value (base64 encoded)
			encoded := base64.StdEncoding.EncodeToString([]byte(cfg.Value))
			sb.WriteString(fmt.Sprintf("  content      = %q\n", encoded))
		}

		sb.WriteString(fmt.Sprintf("  write_only   = %t\n", cfg.WriteOnly))
		sb.WriteString("}\n")
	}

	return sb.String()
}

// generatePolicy creates Tofu for a policy.
func (g *Generator) generatePolicy(policy models.Policy) string {
	resourceName := sanitizeResourceName(policy.ID)

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("resource \"spacelift_policy\" %q {\n", resourceName))
	sb.WriteString(fmt.Sprintf("  name = %q\n", policy.Name))
	sb.WriteString(fmt.Sprintf("  type = %q\n", policy.Type))

	// Space reference
	if policy.Space != "root" {
		spaceResource := sanitizeResourceName(policy.Space)
		sb.WriteString(fmt.Sprintf("  space_id = spacelift_space.%s.id\n", spaceResource))
	} else {
		sb.WriteString("  space_id = \"root\"\n")
	}

	if policy.Description != nil && *policy.Description != "" {
		sb.WriteString(fmt.Sprintf("  description = %q\n", *policy.Description))
	}

	if len(policy.Labels) > 0 {
		sb.WriteString(fmt.Sprintf("  labels = %s\n", formatStringList(policy.Labels)))
	}

	// Policy body using heredoc for readability
	sb.WriteString("  body = <<-EOT\n")
	sb.WriteString(policy.Body)
	if !strings.HasSuffix(policy.Body, "\n") {
		sb.WriteString("\n")
	}
	sb.WriteString("EOT\n")

	sb.WriteString("}\n")
	return sb.String()
}

// generateStack creates Tofu for a stack.
func (g *Generator) generateStack(stack models.Stack) string {
	resourceName := sanitizeResourceName(stack.ID)

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("resource \"spacelift_stack\" %q {\n", resourceName))
	sb.WriteString(fmt.Sprintf("  name       = %q\n", stack.Name))
	sb.WriteString(fmt.Sprintf("  repository = %q\n", stack.Repository))
	sb.WriteString(fmt.Sprintf("  branch     = %q\n", stack.Branch))

	// Space reference
	if stack.Space != "root" {
		spaceResource := sanitizeResourceName(stack.Space)
		sb.WriteString(fmt.Sprintf("  space_id   = spacelift_space.%s.id\n", spaceResource))
	} else {
		sb.WriteString("  space_id   = \"root\"\n")
	}

	// VCS integration override from migration config
	g.writeVCSConfig(&sb, stack)

	if stack.Description != nil && *stack.Description != "" {
		sb.WriteString(fmt.Sprintf("  description = %q\n", *stack.Description))
	}

	if stack.ProjectRoot != nil && *stack.ProjectRoot != "" {
		sb.WriteString(fmt.Sprintf("  project_root = %q\n", *stack.ProjectRoot))
	}

	// Workflow tool and version based on vendor type
	if stack.WorkflowTool != nil && *stack.WorkflowTool != "" && *stack.WorkflowTool != "TERRAFORM" {
		sb.WriteString(fmt.Sprintf("  terraform_workflow_tool = %q\n", *stack.WorkflowTool))
	}

	// Version fields
	if stack.TerraformVersion != nil && *stack.TerraformVersion != "" {
		sb.WriteString(fmt.Sprintf("  terraform_version = %q\n", *stack.TerraformVersion))
	}
	if stack.TerragruntVersion != nil && *stack.TerragruntVersion != "" {
		sb.WriteString(fmt.Sprintf("  terragrunt_version = %q\n", *stack.TerragruntVersion))
	}

	if stack.RunnerImage != nil && *stack.RunnerImage != "" {
		sb.WriteString(fmt.Sprintf("  runner_image = %q\n", *stack.RunnerImage))
	}

	// Note: administrative flag is deprecated - use spacelift_role_attachment instead
	// Role attachment is generated separately for administrative stacks

	// In safe mode, force autodeploy=false to prevent runs during migration
	autodeploy := stack.Autodeploy
	if g.safeMode && stack.Autodeploy {
		autodeploy = false
		sb.WriteString("  autodeploy             = false  # Originally true - re-enable after migration\n")
	} else {
		sb.WriteString(fmt.Sprintf("  autodeploy             = %t\n", autodeploy))
	}

	sb.WriteString(fmt.Sprintf("  autoretry              = %t\n", stack.Autoretry))
	sb.WriteString(fmt.Sprintf("  enable_local_preview   = %t\n", stack.LocalPreviewEnabled))
	sb.WriteString(fmt.Sprintf("  protect_from_deletion  = %t\n", stack.ProtectFromDeletion))
	sb.WriteString(fmt.Sprintf("  manage_state           = %t\n", stack.ManagesStateFile))

	if len(stack.Labels) > 0 {
		sb.WriteString(fmt.Sprintf("  labels = %s\n", formatStringList(stack.Labels)))
	}

	if len(stack.AdditionalProjectGlobs) > 0 {
		sb.WriteString(fmt.Sprintf("  additional_project_globs = %s\n", formatStringList(stack.AdditionalProjectGlobs)))
	}

	// Hooks
	g.writeHooks(&sb, stack.Hooks)

	sb.WriteString("}\n")
	return sb.String()
}

// generateContextAttachment creates Tofu for a context attachment.
func (g *Generator) generateContextAttachment(stackID string, attachment models.ContextAttachment) string {
	stackResource := sanitizeResourceName(stackID)
	contextResource := sanitizeResourceName(attachment.ContextID)
	resourceName := sanitizeResourceName(stackID + "_" + attachment.ContextID)

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("resource \"spacelift_context_attachment\" %q {\n", resourceName))
	sb.WriteString(fmt.Sprintf("  stack_id   = spacelift_stack.%s.id\n", stackResource))
	sb.WriteString(fmt.Sprintf("  context_id = spacelift_context.%s.id\n", contextResource))
	sb.WriteString(fmt.Sprintf("  priority   = %d\n", attachment.Priority))
	sb.WriteString("}\n")
	return sb.String()
}

// generatePolicyAttachment creates Tofu for a policy attachment.
func (g *Generator) generatePolicyAttachment(stackID string, attachment models.PolicyAttachment) string {
	stackResource := sanitizeResourceName(stackID)
	policyResource := sanitizeResourceName(attachment.PolicyID)
	resourceName := sanitizeResourceName(stackID + "_" + attachment.PolicyID)

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("resource \"spacelift_policy_attachment\" %q {\n", resourceName))
	sb.WriteString(fmt.Sprintf("  stack_id  = spacelift_stack.%s.id\n", stackResource))
	sb.WriteString(fmt.Sprintf("  policy_id = spacelift_policy.%s.id\n", policyResource))
	sb.WriteString("}\n")
	return sb.String()
}

// generateStackDependency creates Tofu for a stack dependency.
func (g *Generator) generateStackDependency(stackID string, dep models.StackDependency) string {
	stackResource := sanitizeResourceName(stackID)
	dependsOnResource := sanitizeResourceName(dep.DependsOnStackID)
	resourceName := sanitizeResourceName(stackID + "_depends_on_" + dep.DependsOnStackID)

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("resource \"spacelift_stack_dependency\" %q {\n", resourceName))
	sb.WriteString(fmt.Sprintf("  stack_id            = spacelift_stack.%s.id\n", stackResource))
	sb.WriteString(fmt.Sprintf("  depends_on_stack_id = spacelift_stack.%s.id\n", dependsOnResource))
	sb.WriteString("}\n")
	return sb.String()
}

// generateAdminRoleAttachment creates Tofu for an admin role attachment.
// This replaces the deprecated administrative = true flag on stacks.
func (g *Generator) generateAdminRoleAttachment(stack models.Stack) string {
	stackResource := sanitizeResourceName(stack.ID)
	resourceName := sanitizeResourceName(stack.ID + "_admin_role")

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("resource \"spacelift_role_attachment\" %q {\n", resourceName))
	sb.WriteString("  role_id  = spacelift_role.space_admin.id\n")
	sb.WriteString(fmt.Sprintf("  stack_id = spacelift_stack.%s.id\n", stackResource))
	// Use the stack's space for the role binding
	if stack.Space == "root" {
		sb.WriteString("  space_id = \"root\"\n")
	} else {
		spaceResource := sanitizeResourceName(stack.Space)
		sb.WriteString(fmt.Sprintf("  space_id = spacelift_space.%s.id\n", spaceResource))
	}
	sb.WriteString("}\n")
	return sb.String()
}

// generateAdminRole creates the shared SPACE_ADMIN role for administrative stacks.
func (g *Generator) generateAdminRole() string {
	var sb strings.Builder
	sb.WriteString("# Shared role for administrative stacks (replaces deprecated administrative = true)\n")
	sb.WriteString("resource \"spacelift_role\" \"space_admin\" {\n")
	sb.WriteString("  name    = \"Space Admin (Migration)\"\n")
	sb.WriteString("  actions = [\"SPACE_ADMIN\"]\n")
	sb.WriteString("}\n")
	return sb.String()
}

// generateAWSIntegration creates Tofu for an AWS integration.
func (g *Generator) generateAWSIntegration(integration models.AWSIntegration) string {
	resourceName := sanitizeResourceName(integration.ID)

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("resource \"spacelift_aws_integration\" %q {\n", resourceName))
	sb.WriteString(fmt.Sprintf("  name     = %q\n", integration.Name))
	sb.WriteString(fmt.Sprintf("  role_arn = %q\n", integration.RoleARN))

	// Space reference
	if integration.Space != "root" {
		spaceResource := sanitizeResourceName(integration.Space)
		sb.WriteString(fmt.Sprintf("  space_id = spacelift_space.%s.id\n", spaceResource))
	} else {
		sb.WriteString("  space_id = \"root\"\n")
	}

	if integration.DurationSeconds > 0 {
		sb.WriteString(fmt.Sprintf("  duration_seconds = %d\n", integration.DurationSeconds))
	}

	sb.WriteString(fmt.Sprintf("  generate_credentials_in_worker = %t\n", integration.GenerateCredentialsInWorker))

	if integration.ExternalID != nil && *integration.ExternalID != "" {
		sb.WriteString(fmt.Sprintf("  external_id = %q\n", *integration.ExternalID))
	}

	if len(integration.Labels) > 0 {
		sb.WriteString(fmt.Sprintf("  labels = %s\n", formatStringList(integration.Labels)))
	}

	sb.WriteString("}\n")
	return sb.String()
}

// generateAzureIntegration creates Tofu for an Azure integration.
func (g *Generator) generateAzureIntegration(integration models.AzureIntegration) string {
	resourceName := sanitizeResourceName(integration.ID)

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("resource \"spacelift_azure_integration\" %q {\n", resourceName))
	sb.WriteString(fmt.Sprintf("  name       = %q\n", integration.Name))
	sb.WriteString(fmt.Sprintf("  tenant_id  = %q\n", integration.TenantID))
	sb.WriteString(fmt.Sprintf("  application_id = %q\n", integration.ApplicationID))

	// Space reference
	if integration.Space != "root" {
		spaceResource := sanitizeResourceName(integration.Space)
		sb.WriteString(fmt.Sprintf("  space_id = spacelift_space.%s.id\n", spaceResource))
	} else {
		sb.WriteString("  space_id = \"root\"\n")
	}

	if integration.DefaultSubscriptionID != nil && *integration.DefaultSubscriptionID != "" {
		sb.WriteString(fmt.Sprintf("  default_subscription_id = %q\n", *integration.DefaultSubscriptionID))
	}

	if len(integration.Labels) > 0 {
		sb.WriteString(fmt.Sprintf("  labels = %s\n", formatStringList(integration.Labels)))
	}

	sb.WriteString("}\n")
	return sb.String()
}

// generateAWSIntegrationAttachment creates Tofu for an AWS integration attachment to a stack.
func (g *Generator) generateAWSIntegrationAttachment(stackID string, attachment models.AWSIntegrationAttachment) string {
	stackResource := sanitizeResourceName(stackID)
	integrationResource := sanitizeResourceName(attachment.IntegrationID)
	resourceName := sanitizeResourceName(stackID + "_aws_" + attachment.IntegrationID)

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("resource \"spacelift_aws_integration_attachment\" %q {\n", resourceName))
	sb.WriteString(fmt.Sprintf("  integration_id = spacelift_aws_integration.%s.id\n", integrationResource))
	sb.WriteString(fmt.Sprintf("  stack_id       = spacelift_stack.%s.id\n", stackResource))
	sb.WriteString(fmt.Sprintf("  read           = %t\n", attachment.Read))
	sb.WriteString(fmt.Sprintf("  write          = %t\n", attachment.Write))
	sb.WriteString("}\n")
	return sb.String()
}

// generateAzureIntegrationAttachment creates Tofu for an Azure integration attachment to a stack.
func (g *Generator) generateAzureIntegrationAttachment(stackID string, attachment models.AzureIntegrationAttachment) string {
	stackResource := sanitizeResourceName(stackID)
	integrationResource := sanitizeResourceName(attachment.IntegrationID)
	resourceName := sanitizeResourceName(stackID + "_azure_" + attachment.IntegrationID)

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("resource \"spacelift_azure_integration_attachment\" %q {\n", resourceName))
	sb.WriteString(fmt.Sprintf("  integration_id = spacelift_azure_integration.%s.id\n", integrationResource))
	sb.WriteString(fmt.Sprintf("  stack_id       = spacelift_stack.%s.id\n", stackResource))
	sb.WriteString(fmt.Sprintf("  read           = %t\n", attachment.Read))
	sb.WriteString(fmt.Sprintf("  write          = %t\n", attachment.Write))
	if attachment.SubscriptionID != nil && *attachment.SubscriptionID != "" {
		sb.WriteString(fmt.Sprintf("  subscription_id = %q\n", *attachment.SubscriptionID))
	}
	sb.WriteString("}\n")
	return sb.String()
}

// writeVCSConfig writes VCS integration configuration based on migration config.
func (g *Generator) writeVCSConfig(sb *strings.Builder, stack models.Stack) {
	if g.migrationConfig == nil {
		return
	}

	vcs := &g.migrationConfig.Destination.VCS
	if !vcs.HasVCSOverride() {
		return
	}

	// Write the appropriate VCS block based on config
	if vcs.GithubEnterprise != nil {
		sb.WriteString("\n  github_enterprise {\n")
		sb.WriteString(fmt.Sprintf("    id        = %q\n", vcs.GithubEnterprise.ID))
		sb.WriteString(fmt.Sprintf("    namespace = %q\n", vcs.GithubEnterprise.Namespace))
		sb.WriteString("  }\n")
	} else if vcs.Gitlab != nil {
		sb.WriteString("\n  gitlab {\n")
		sb.WriteString(fmt.Sprintf("    id        = %q\n", vcs.Gitlab.ID))
		sb.WriteString(fmt.Sprintf("    namespace = %q\n", vcs.Gitlab.Namespace))
		sb.WriteString("  }\n")
	} else if vcs.BitbucketDatacenter != nil {
		sb.WriteString("\n  bitbucket_datacenter {\n")
		sb.WriteString(fmt.Sprintf("    id        = %q\n", vcs.BitbucketDatacenter.ID))
		sb.WriteString(fmt.Sprintf("    namespace = %q\n", vcs.BitbucketDatacenter.Namespace))
		sb.WriteString("  }\n")
	} else if vcs.BitbucketCloud != nil {
		sb.WriteString("\n  bitbucket_cloud {\n")
		sb.WriteString(fmt.Sprintf("    id        = %q\n", vcs.BitbucketCloud.ID))
		sb.WriteString(fmt.Sprintf("    namespace = %q\n", vcs.BitbucketCloud.Namespace))
		sb.WriteString("  }\n")
	} else if vcs.AzureDevops != nil {
		sb.WriteString("\n  azure_devops {\n")
		sb.WriteString(fmt.Sprintf("    id      = %q\n", vcs.AzureDevops.ID))
		sb.WriteString(fmt.Sprintf("    project = %q\n", vcs.AzureDevops.Project))
		sb.WriteString("  }\n")
	}
}

// writeHooks writes hook configuration to the string builder.
func (g *Generator) writeHooks(sb *strings.Builder, hooks models.Hooks) {
	if len(hooks.BeforeInit) > 0 {
		sb.WriteString(fmt.Sprintf("  before_init = %s\n", formatStringList(hooks.BeforeInit)))
	}
	if len(hooks.AfterInit) > 0 {
		sb.WriteString(fmt.Sprintf("  after_init = %s\n", formatStringList(hooks.AfterInit)))
	}
	if len(hooks.BeforePlan) > 0 {
		sb.WriteString(fmt.Sprintf("  before_plan = %s\n", formatStringList(hooks.BeforePlan)))
	}
	if len(hooks.AfterPlan) > 0 {
		sb.WriteString(fmt.Sprintf("  after_plan = %s\n", formatStringList(hooks.AfterPlan)))
	}
	if len(hooks.BeforeApply) > 0 {
		sb.WriteString(fmt.Sprintf("  before_apply = %s\n", formatStringList(hooks.BeforeApply)))
	}
	if len(hooks.AfterApply) > 0 {
		sb.WriteString(fmt.Sprintf("  after_apply = %s\n", formatStringList(hooks.AfterApply)))
	}
	if len(hooks.BeforeDestroy) > 0 {
		sb.WriteString(fmt.Sprintf("  before_destroy = %s\n", formatStringList(hooks.BeforeDestroy)))
	}
	if len(hooks.AfterDestroy) > 0 {
		sb.WriteString(fmt.Sprintf("  after_destroy = %s\n", formatStringList(hooks.AfterDestroy)))
	}
	if len(hooks.BeforePerform) > 0 {
		sb.WriteString(fmt.Sprintf("  before_perform = %s\n", formatStringList(hooks.BeforePerform)))
	}
	if len(hooks.AfterPerform) > 0 {
		sb.WriteString(fmt.Sprintf("  after_perform = %s\n", formatStringList(hooks.AfterPerform)))
	}
	if len(hooks.AfterRun) > 0 {
		sb.WriteString(fmt.Sprintf("  after_run = %s\n", formatStringList(hooks.AfterRun)))
	}
}

// generateVariables creates variables.tf for all secrets.
func (g *Generator) generateVariables() string {
	var sb strings.Builder

	sb.WriteString(`# Variables for secrets
# These values could not be exported from the source account.
# Fill in the values in secrets.auto.tfvars

`)

	for _, ctx := range g.manifest.Contexts {
		for _, cfg := range ctx.Config {
			if cfg.WriteOnly {
				varName := sanitizeVariableName(ctx.ID + "_" + cfg.ID)
				sb.WriteString(fmt.Sprintf("variable \"secret_%s\" {\n", varName))
				sb.WriteString(fmt.Sprintf("  description = \"Secret for context '%s', config '%s' (%s)\"\n", ctx.Name, cfg.ID, cfg.Type))
				sb.WriteString("  type        = string\n")
				sb.WriteString("  sensitive   = true\n")
				sb.WriteString("}\n\n")
			}
		}
	}

	return sb.String()
}

// generateSecretsTemplate creates the template for secret values.
func (g *Generator) generateSecretsTemplate() string {
	var sb strings.Builder

	sb.WriteString(`# Secret values template
# Rename this file to secrets.auto.tfvars and fill in the values.
# WARNING: Do not commit this file to version control!
#
# For file mounts, provide the file content as a string.
# You can use file() function in Tofu.tfvars if needed.

`)

	for _, ctx := range g.manifest.Contexts {
		hasSecrets := false
		for _, cfg := range ctx.Config {
			if cfg.WriteOnly {
				hasSecrets = true
				break
			}
		}

		if hasSecrets {
			sb.WriteString(fmt.Sprintf("# Context: %s (%s)\n", ctx.Name, ctx.ID))
			for _, cfg := range ctx.Config {
				if cfg.WriteOnly {
					varName := sanitizeVariableName(ctx.ID + "_" + cfg.ID)
					if cfg.Type == "FILE_MOUNT" {
						sb.WriteString(fmt.Sprintf("secret_%s = \"\" # FILE_MOUNT: %s\n", varName, cfg.ID))
					} else {
						sb.WriteString(fmt.Sprintf("secret_%s = \"\" # %s\n", varName, cfg.ID))
					}
				}
			}
			sb.WriteString("\n")
		}
	}

	return sb.String()
}

// generateAutodeployReEnable creates a file with stack updates to re-enable autodeploy.
func (g *Generator) generateAutodeployReEnable() string {
	var sb strings.Builder

	sb.WriteString(`# Autodeploy Re-enable Configuration
# ==================================
# These stacks originally had autodeploy = true but were set to false
# for safe state migration.
#
# After migration is complete:
# 1. Rename this file to autodeploy_re_enable.tf (remove .disabled)
# 2. Run: tofu apply
# 3. Delete this file or keep for reference
#
# Alternatively, update autodeploy in main.tf directly.

`)

	for _, stackName := range g.autodeployList {
		resourceName := sanitizeResourceName(stackName)
		sb.WriteString(fmt.Sprintf(`# Re-enable autodeploy for: %s
resource "spacelift_stack" "%s" {
  autodeploy = true
}

`, stackName, resourceName))
	}

	sb.WriteString(fmt.Sprintf("# Total stacks to re-enable: %d\n", len(g.autodeployList)))

	return sb.String()
}

// sortSpacesByDependency sorts spaces so parents come before children.
func (g *Generator) sortSpacesByDependency() []models.Space {
	// Build dependency map
	spaceMap := make(map[string]models.Space)
	for _, s := range g.manifest.Spaces {
		spaceMap[s.ID] = s
	}

	// Topological sort
	visited := make(map[string]bool)
	var result []models.Space

	var visit func(id string)
	visit = func(id string) {
		if visited[id] {
			return
		}
		visited[id] = true

		space, ok := spaceMap[id]
		if !ok {
			return
		}

		// Visit parent first
		if space.ParentSpace != nil && *space.ParentSpace != "" && *space.ParentSpace != "root" {
			visit(*space.ParentSpace)
		}

		result = append(result, space)
	}

	for _, space := range g.manifest.Spaces {
		visit(space.ID)
	}

	return result
}

// sanitizeResourceName converts an ID to a valid Tofu resource name.
func sanitizeResourceName(id string) string {
	// Replace invalid characters with underscores
	re := regexp.MustCompile(`[^a-zA-Z0-9_]`)
	name := re.ReplaceAllString(id, "_")

	// Ensure it starts with a letter or underscore
	if len(name) > 0 && name[0] >= '0' && name[0] <= '9' {
		name = "_" + name
	}

	return name
}

// sanitizeVariableName is similar but for variable names.
func sanitizeVariableName(id string) string {
	re := regexp.MustCompile(`[^a-zA-Z0-9_]`)
	name := re.ReplaceAllString(id, "_")

	// Remove consecutive underscores
	re2 := regexp.MustCompile(`_+`)
	name = re2.ReplaceAllString(name, "_")

	// Trim underscores from ends
	name = strings.Trim(name, "_")

	// Ensure it starts with a letter or underscore
	if len(name) > 0 && name[0] >= '0' && name[0] <= '9' {
		name = "_" + name
	}

	return name
}

// formatStringList formats a Go string slice as a Tofu list.
func formatStringList(items []string) string {
	if len(items) == 0 {
		return "[]"
	}

	quoted := make([]string, len(items))
	for i, item := range items {
		quoted[i] = fmt.Sprintf("%q", item)
	}

	return "[" + strings.Join(quoted, ", ") + "]"
}
